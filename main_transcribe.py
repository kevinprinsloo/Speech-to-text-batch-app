#!/usr/bin/env python
# coding: utf-8

import logging
import sys
import requests
import time
import yaml
import swagger_client
from azure.storage.blob import (
    BlobServiceClient,
    generate_blob_sas,
    generate_container_sas,
    ContainerSasPermissions,
    BlobSasPermissions,
)
from datetime import datetime, timedelta, timezone

# Load configuration from config.yaml
with open('config.yaml', 'r') as file:
    config = yaml.safe_load(file)

CONNECTION_STRING = config['connection_string']
OUTPUT_CONTAINER_NAME = config['output_container_name']
BLOB_NAME = config['blob_name']
DOWNLOAD_FILE_PATH = config['download_file_path']
SUBSCRIPTION_KEY = config['subscription_key']
SERVICE_REGION = config['service_region']
RECORDINGS_CONTAINER_NAME = config['recordings_container_name']
RECORDINGS_BLOB_NAME = config['recordings_blob_name']

logging.basicConfig(
    stream=sys.stdout,
    level=logging.DEBUG,
    format="%(asctime)s %(message)s",
    datefmt="%m/%d/%Y %I:%M:%S %p %Z",
)

NAME = "Simple transcription"
DESCRIPTION = "Simple transcription description"
LOCALE = "en-US"

# Define a function to generate a valid SAS URL
def generate_sas_url(container_name, blob_name, permission, expiry_duration_hours):
    blob_service_client = BlobServiceClient.from_connection_string(CONNECTION_STRING)
    sas_token = generate_blob_sas(
        account_name=blob_service_client.account_name,
        container_name=container_name,
        blob_name=blob_name,
        account_key=blob_service_client.credential.account_key,
        permission=permission,
        expiry=datetime.now(timezone.utc) + timedelta(hours=expiry_duration_hours),
    )
    sas_url = f"https://{blob_service_client.account_name}.blob.core.windows.net/{container_name}/{blob_name}?{sas_token}"
    return sas_url

# Generate a new SAS URL for the recordings blob
recordings_blob_sas_url = generate_sas_url(
    RECORDINGS_CONTAINER_NAME,
    RECORDINGS_BLOB_NAME,
    BlobSasPermissions(read=True),
    8,
)  # 8 hours expiry

# Generate a new SAS URL for the output container
def generate_container_sas_url(container_name, permission, expiry_duration_hours):
    blob_service_client = BlobServiceClient.from_connection_string(CONNECTION_STRING)
    sas_token = generate_container_sas(
        account_name=blob_service_client.account_name,
        container_name=container_name,
        account_key=blob_service_client.credential.account_key,
        permission=permission,
        expiry=datetime.now(timezone.utc) + timedelta(hours=expiry_duration_hours),
    )
    sas_url = f"https://{blob_service_client.account_name}.blob.core.windows.net/{container_name}?{sas_token}"
    return sas_url

# Set model information when doing transcription with custom models
MODEL_REFERENCE = None  # guid of a custom model

def transcribe_from_single_blob(uri, properties):
    """
    Transcribe a single audio file located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_urls=[uri],
        properties=properties,
    )
    return transcription_definition

def transcribe_with_custom_model(client, uri, properties):
    """
    Transcribe a single audio file located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    # Model information (ADAPTED_ACOUSTIC_ID and ADAPTED_LANGUAGE_ID) must be set above.
    if MODEL_REFERENCE is None:
        logging.error("Custom model ids must be set when using custom models")
        sys.exit()

    model = {"self": f"{client.configuration.host}/models/{MODEL_REFERENCE}"}

    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_urls=[uri],
        model=model,
        properties=properties,
    )

    return transcription_definition

def transcribe_from_container(uri, properties):
    """
    Transcribe all files in the container located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_container_url=uri,
        properties=properties,
    )
    return transcription_definition

def _paginate(api, paginated_object):
    """
    The autogenerated client does not support pagination. This function returns a generator over
    all items of the array that the paginated object `paginated_object` is part of.
    """
    yield from paginated_object.values
    typename = type(paginated_object).__name__
    auth_settings = ["api_key"]
    while paginated_object.next_link:
        link = paginated_object.next_link[len(api.api_client.configuration.host) :]
        paginated_object, status, headers = api.api_client.call_api(
            link, "GET", response_type=typename, auth_settings=auth_settings
        )

        if status == 200:
            yield from paginated_object.values
        else:
            raise Exception(f"could not receive paginated data: status {status}")

def delete_all_transcriptions(api):
    """
    Delete all transcriptions associated with your speech resource.
    """
    logging.info("Deleting all existing completed transcriptions.")

    # get all transcriptions for the subscription
    transcriptions = list(_paginate(api, api.get_transcriptions()))

    # Delete all pre-existing completed transcriptions.
    # If transcriptions are still running or not started, they will not be deleted.
    for transcription in transcriptions:
        transcription_id = transcription._self.split("/")[-1]
        logging.debug(f"Deleting transcription with id {transcription_id}")
        try:
            api.delete_transcription(transcription_id)
        except swagger_client.rest.ApiException as exc:
            logging.error(f"Could not delete transcription {transcription_id}: {exc}")

def save_transcription_id(transcription_id, file_path):
    with open(file_path, 'a') as f:
        f.write(f"{transcription_id}\n")

def transcribe():
    logging.info("Starting transcription client...")

    # configure API key authorization: subscription_key
    configuration = swagger_client.Configuration()
    configuration.api_key["Ocp-Apim-Subscription-Key"] = SUBSCRIPTION_KEY
    configuration.host = (
        f"https://{SERVICE_REGION}.api.cognitive.microsoft.com/speechtotext/v3.1"
    )

    # create the client object and authenticate
    client = swagger_client.ApiClient(configuration)

    # create an instance of the transcription api class
    api = swagger_client.CustomSpeechTranscriptionsApi(api_client=client)

    # Specify transcription properties by passing a dict to the properties parameter.
    properties = swagger_client.TranscriptionProperties()
    properties.word_level_timestamps_enabled = True
    properties.display_form_word_level_timestamps_enabled = True
    properties.punctuation_mode = "DictatedAndAutomatic"
    properties.profanity_filter_mode = "Masked"

    # Generate a new SAS URL for the output container
    properties.destination_container_url = generate_container_sas_url(
        OUTPUT_CONTAINER_NAME,
        ContainerSasPermissions(
            read=True, add=True, create=True, write=True, delete=True, list=True
        ),
        8,
    )  # 8 hours expiry

    # Enable and configure speaker separation
    properties.diarization_enabled = True
    properties.diarization = swagger_client.DiarizationProperties(
        swagger_client.DiarizationSpeakersProperties(min_count=1, max_count=5)
    )

    transcription_definition = transcribe_from_single_blob(
        recordings_blob_sas_url, properties
    )

    created_transcription, status, headers = api.transcriptions_create_with_http_info(
        transcription=transcription_definition
    )

    # get the transcription Id from the location URI
    transcription_id = headers["location"].split("/")[-1]

    # Save transcription ID to a file
    save_transcription_id(transcription_id, 'transcription_ids.txt')

    logging.info(
        "Created new transcription with id '%s' in region %s",
        transcription_id,
        SERVICE_REGION,
    )

    logging.info("Checking status.")

    completed = False

    while not completed:
        time.sleep(5)
        transcription = api.transcriptions_get(transcription_id)
        logging.info("Transcriptions status: %s", transcription.status)

        if transcription.status in ("Failed", "Succeeded"):
            completed = True

        if transcription.status == "Succeeded":
            if properties.destination_container_url is not None:
                logging.info(
                    "Transcription succeeded. Results are located in your Azure Blob Storage."
                )
                break

            pag_files = api.transcriptions_list_files(transcription_id)
            for file_data in _paginate(api, pag_files):
                if file_data.kind != "Transcription":
                    continue

                audiofilename = file_data.name
                results_url = file_data.links.content_url
                results = requests.get(results_url, timeout=10)
                logging.info(
                    "Results for %s:\n%s",
                    audiofilename,
                    results.content.decode("utf-8"),
                )
        elif transcription.status == "Failed":
            logging.info(
                "Transcription failed: %s", transcription.properties.error.message
            )

if __name__ == "__main__":
    transcribe()
