#!/usr/bin/env python
# coding: utf-8

import json
import logging
import sys
import requests
import time
import yaml
import swagger_client
from azure.storage.blob import (
    BlobServiceClient,
    generate_blob_sas,
    generate_container_sas,
    ContainerSasPermissions,
    BlobSasPermissions,
)
from datetime import datetime, timedelta, timezone

# Load configuration from config.yaml
with open('config.yaml', 'r') as file:
    config = yaml.safe_load(file)

CONNECTION_STRING = config['connection_string']
OUTPUT_CONTAINER_NAME = config['output_container_name']
SUBSCRIPTION_KEY = config['subscription_key']
SERVICE_REGION = config['service_region']
INPUT_CONTAINER_NAME = config['input_container_name']

logging.basicConfig(
    stream=sys.stdout,
    level=logging.DEBUG,
    format="%(asctime)s %(message)s",
    datefmt="%m/%d/%Y %I:%M:%S %p %Z",
)

class DateTimeEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        return super(DateTimeEncoder, self).default(obj)


NAME = "Simple transcription"
DESCRIPTION = "Simple transcription description"
LOCALE = "en-US"

# Define a function to generate a valid SAS URL
def generate_sas_url(container_name, blob_name, permission, expiry_duration_hours):
    blob_service_client = BlobServiceClient.from_connection_string(CONNECTION_STRING)
    blob_client = blob_service_client.get_blob_client(container=container_name, blob=blob_name)
    
    if not blob_client.exists():
        raise Exception(f"Blob does not exist: {blob_name}")
    
    sas_token = generate_blob_sas(
        account_name=blob_service_client.account_name,
        container_name=container_name,
        blob_name=blob_name,
        account_key=blob_service_client.credential.account_key,
        permission=permission,
        expiry=datetime.now(timezone.utc) + timedelta(hours=expiry_duration_hours),
    )
    sas_url = f"https://{blob_service_client.account_name}.blob.core.windows.net/{container_name}/{blob_name}?{sas_token}"
    
    # Test the SAS URL
    try:
        response = requests.head(sas_url)
        response.raise_for_status()
        logging.info(f"SAS URL is valid and accessible: {sas_url}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error accessing SAS URL: {e}")
        raise Exception(f"Invalid SAS URL: {sas_url}")
    
    return sas_url

# Define a function to generate a valid SAS URL for a container
def generate_container_sas_url(container_name, permission, expiry_duration_hours):
    blob_service_client = BlobServiceClient.from_connection_string(CONNECTION_STRING)
    sas_token = generate_container_sas(
        account_name=blob_service_client.account_name,
        container_name=container_name,
        account_key=blob_service_client.credential.account_key,
        permission=permission,
        expiry=datetime.now(timezone.utc) + timedelta(hours=expiry_duration_hours),
    )
    sas_url = f"https://{blob_service_client.account_name}.blob.core.windows.net/{container_name}?{sas_token}"
    return sas_url

# Set model information when doing transcription with custom models
MODEL_REFERENCE = None  # guid of a custom model

def transcribe_from_single_blob(uri, properties):
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_urls=[uri],  # Ensure this is a list with the URI
        properties=properties,
    )
    logging.info(f"Transcription definition created with content_urls: {transcription_definition.content_urls}")
    return transcription_definition

def transcribe_with_custom_model(client, uri, properties):
    """
    Transcribe a single audio file located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    # Model information (ADAPTED_ACOUSTIC_ID and ADAPTED_LANGUAGE_ID) must be set above.
    if MODEL_REFERENCE is None:
        logging.error("Custom model ids must be set when using custom models")
        sys.exit()

    model = {"self": f"{client.configuration.host}/models/{MODEL_REFERENCE}"}

    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_urls=[uri],
        model=model,
        properties=properties,
    )

    return transcription_definition

def transcribe_from_container(uri, properties):
    """
    Transcribe all files in the container located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_container_url=uri,
        properties=properties,
    )
    return transcription_definition

def _paginate(api, paginated_object):
    """
    The autogenerated client does not support pagination. This function returns a generator over
    all items of the array that the paginated object `paginated_object` is part of.
    """
    yield from paginated_object.values
    typename = type(paginated_object).__name__
    auth_settings = ["api_key"]
    while paginated_object.next_link:
        link = paginated_object.next_link[len(api.api_client.configuration.host) :]
        paginated_object, status, headers = api.api_client.call_api(
            link, "GET", response_type=typename, auth_settings=auth_settings
        )

        if status == 200:
            yield from paginated_object.values
        else:
            raise Exception(f"could not receive paginated data: status {status}")

def delete_all_transcriptions(api):
    """
    Delete all transcriptions associated with your speech resource.
    """
    logging.info("Deleting all existing completed transcriptions.")

    # get all transcriptions for the subscription
    transcriptions = list(_paginate(api, api.get_transcriptions()))

    # Delete all pre-existing completed transcriptions.
    # If transcriptions are still running or not started, they will not be deleted.
    for transcription in transcriptions:
        transcription_id = transcription._self.split("/")[-1]
        logging.debug(f"Deleting transcription with id {transcription_id}")
        try:
            api.delete_transcription(transcription_id)
        except swagger_client.rest.ApiException as exc:
            logging.error(f"Could not delete transcription {transcription_id}: {exc}")

def save_transcription_id(transcription_id, file_path):
    with open(file_path, 'w') as f:  # Changed from 'a' to 'w' to overwrite
        f.write(f"{transcription_id}\n")
    logging.info(f"Saved transcription ID {transcription_id} to {file_path}")

def check_transcription_status(api, transcription_id, max_retries=180):  # 15 minutes
    retry_count = 0
    while retry_count < max_retries:
        time.sleep(5)
        transcription = api.transcriptions_get(transcription_id)
        logging.info("Transcriptions status: %s", transcription.status)

        if transcription.status in ("Failed", "Succeeded"):
            return transcription

        retry_count += 1

    return None

def transcribe():
    logging.info("Starting transcription client...")

    configuration = swagger_client.Configuration()
    configuration.api_key["Ocp-Apim-Subscription-Key"] = config['subscription_key']
    configuration.host = f"https://{config['service_region']}.api.cognitive.microsoft.com/speechtotext/v3.1"

    client = swagger_client.ApiClient(configuration)
    api = swagger_client.CustomSpeechTranscriptionsApi(api_client=client)

    properties = swagger_client.TranscriptionProperties()
    properties.word_level_timestamps_enabled = True
    properties.display_form_word_level_timestamps_enabled = True
    properties.punctuation_mode = "DictatedAndAutomatic"
    properties.profanity_filter_mode = "Masked"

    properties.destination_container_url = generate_container_sas_url(
        OUTPUT_CONTAINER_NAME,
        ContainerSasPermissions(read=True, add=True, create=True, write=True, delete=True, list=True),
        8,
    )

    properties.diarization_enabled = True
    properties.diarization = swagger_client.DiarizationProperties(
        swagger_client.DiarizationSpeakersProperties(min_count=1, max_count=5)
    )

    try:
        with open('current_file_info.txt', 'r') as file:
            unique_id, blob_name = file.read().strip().split(',')

        logging.info(f"Read from current_file_info.txt: unique_id={unique_id}, blob_name={blob_name}")

        recordings_blob_sas_url = generate_sas_url(
            INPUT_CONTAINER_NAME,
            blob_name,
            BlobSasPermissions(read=True),
            48,
        )
        logging.info(f"Generated SAS URL for blob: {blob_name}")
        logging.info(f"In container: {INPUT_CONTAINER_NAME}")
        logging.info(f"Full SAS URL: {recordings_blob_sas_url}")

        transcription_definition = transcribe_from_single_blob(recordings_blob_sas_url, properties)

        created_transcription, status, headers = api.transcriptions_create_with_http_info(
            transcription=transcription_definition
        )

        transcription_id = headers["location"].split("/")[-1]
        save_transcription_id(transcription_id, 'transcription_ids.txt')

        logging.info(
            "Created new transcription with id '%s' in region %s",
            transcription_id,
            config['service_region'],
        )

        logging.info("Checking status.")

        transcription = check_transcription_status(api, transcription_id)

        if transcription is None:
            logging.warning("Transcription is still running after the initial timeout. It will continue in the background.")
            logging.info(f"Transcription ID: {transcription_id}")
            return transcription_id

        if transcription.status == "Succeeded":
            logging.info("Transcription succeeded. Results are located in your Azure Blob Storage.")
        elif transcription.status == "Failed":
            error_details = transcription.to_dict()
            error_message = json.dumps(error_details, indent=2, cls=DateTimeEncoder)
            logging.error(f"Transcription failed. Error details:\n{error_message}")
            raise Exception(f"Transcription failed: {error_message}")

        return transcription_id

    except Exception as e:
        logging.error(f"Error in transcription process: {e}")
        raise

if __name__ == "__main__":
    transcription_id = transcribe()
    print(f"Transcription ID: {transcription_id}")